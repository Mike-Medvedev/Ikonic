# Front End Learnings!

## Folder Structure

1. The Folder structure of the app should promote modularity as well as highlight shared resources.
2. The Main code should belong inside the src folder
3. The frontend should follow a feature module system, where each feature is its own entity decoupled with the others
4. Features/ should contain a FeatureName/ with components/ views/ and services/
5. lib/ should contain shared resources such as common clients, and core files to the entire application
6. Shared components should be in a global share Components/
7. utils/ contain convenience functions that are pure
8. types/ should contain all the types used by the system, this includes frontend specific types as well as domain entites from the backend (the source of truth)
9. Types should be auto generated and not modifed in the generated directory/

## Centralized Logic

1. Use Context Providers or Service Layers to inject logic globally i.e(Theme, Auth, Settings)
2. Applications should contain patterns to centralize and unify common operations such as data fetching, error handling, etc
3. For example, a centralized data fetching layer, containing a generic request handler, shared across all modules who need access to external resources
4. Centralized error handling system is another example, creating custom error classes to catch errors locally. Errors that bubble up towards the boundries of the system should be caught by error boundries, and unhandled exceptions
5. Error boundries catch run time errors during rendering and component life cycle error. event handlers/ async operations/ useEffect need to be caught seperately.

## Generated Types/SDK

1. A system contains Domain entites that model real world scenarios, types/interfaces describe what they mean to a system
2. the backend contains the source of truth and should have its entities auto generated by something like hey-openapi, these files should not be modified.
3. re-export these types via BARREL FILES and perform any serialization/parsing such as converting strings back to dates
4. UI specific types used only on the frontend should also be defined and re-exported

## Programming to an interface (Write the contract first!!!)

1. DEVELOP INTERFACES FIRST, IMPLEMENTATION SECOND. This saves so much time and refactoring later.
2. operations should be responsible for one thing (SINGLE RESPONSBILITY PRINCIPLE)
3. operations consuming dependencies should not instantiate, rather inject with a defined type(DEPENDENCY INVERSION PRINCIPLE)
4. abstractions dedicated to reducing code duplication (DRY) such as factory patterns. custom hooks for reusable/shared logic, as well as reducing a modules workload(SINGLE RESPONSIBILITY)

## NO MAGIC STRINGS

1. Perfer variables and constants for working with string values. define types for natural language types (type = "accepted" | "rejected")
2. Define Constants.ts file for defining constants so a changing a constant only affects one module (Module should only have one reason to chagne)

## UI vs business logic

1. React should only be responsible for Rendering UI. business logic, data access, serialization, statemanagement should be abstracted!

## Functional programming

1. Prefer Functional Programming to Object Oriented.
2. Leverage Closures over Classes. Easier to compose, no this, easier to test
3. Try to write pure functions as much as possible, easier testing, easier maintainability
4. Perfer Immutability, returning new objects instead of operating on them in place. Abstract/Isolate Side effects and inject. (DI principle)
5. Prefer Functinal Composition over inheritance, i.e { key: () => someValue } > class { method() { return someValue } }

## Error Handling

1. Handling Errors are critical business logic, pertinent to UX/UI
2. Always create custom error classes to define specific errors.
3. Key to errors is understanding they propogate up the call stack until they hit a catch handler.
4. Fail Fast! Catch them asap, re raise if the the catch doesnt have the context to handle the error. Use this time to Classidy them with a custom exception
5. Centralize error handling system and hav a global error boundry to catch errors that slip through
6. Errors during rendering and component lifecycle are bound to react. Async errors/eventhandler errors are outside react understanding this is crucial

## Code Quality

1. Setup Linting Formating and TypeChecking to project to ensure clean and consisten codebase
2. Eslint is a popular js linter with lots of rules and custom plugins, import eslint plugins and specify what rules to use, and ad custom configs for them
3. Prettier is a popular formatter that uses a config file to format all files (configure format on save in settings.json)
4. husky is a git hook util that hooks into git lifecycle like pre-commit and runs scripts
5. use husky to run linting, formatting, and typechecking on every commit to ensure code base stays pristine
6. use typescript tsc --noEmit to check types before commit
7. Add Jsdoc to all classes and functions to completely document codebase, prefer describing WHY not WHAT a piece of code does. (use jsdoc linting tool)

## File Routing

1. File Routing involves a special directory where each file represents a route that renders a page
2. Navigation in principle is modeled by a Navigation stack which pushes and pops routes the users visit
3. File Routing is picked by expo so it can be platform agnostic
4. Each directory (usually) has a (\_layout.tsx) which provides and overrides a layout for the routes in this nesting
5. Navigation gets complicated when you start to nest navigators, its important to
   pay attention which navigator controls the current route and visualize both are a Stack
6. In this project (Expo) IF you nest navigators, you need to ensure when navigating between nested layers, the nested navigators are properly popping and pushing routes onto their stack
7. Pay attention to wear custom hooks call a navigator, like useNavigation() will yield different results based on which file calls it.
